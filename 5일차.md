<hr>

# 네줄리뷰(Four Lines Review)

<hr>

## 사실(Facts): 어떠한 일들이 있었는지
### 함수 ###

#### 1. 파라미터의 개수가 정해지지 않은 함수 ####

- 예시
```
def person_info1(*args, name, age):
    return {'age': age, 'name': name, 'favorNums': args}
    

person_info1(5,6,7, name='xxx', age=24)

```

- 결과
```
{'age': 24, 'name': 'xxx', 'favorNums': (5, 6, 7)}
```
-> ***args**를 통해 입력받는 값의 개수를 제한하지 않음

<br/>

#### 2. 지역변수 & 전역변수 ####

- **지역변수(Local)**
    - 함수 안에서 정의한 변수를 뜻함
    - 함수가 실행되는 동안만 메모리에 있음 (함수가 종료되면 사라짐)

- **전역변수(Global)**
    - 함수 밖에서도 사용이 가능한 변수
    - 함수 안에서 정의한 변수 앞에 'global'을 붙이면 지역변수지만, 전역변수처럼 사용할 수 있음 !
    - (함수를 호출해야만 생겨나는 변수를 함수 밖에서 사용해야할 때 주로 global 키워드를 이용)

- **지역변수와 전역변수를 나누는 이유**
    - 전역변수가 위험하기 때문
    - 방대한 양의 코드를 여러 개발자가 작성하고 있다면 변수명이 겹칠 수도 있고 ...
    - 지역변수와 전역변수가 같다면, **지역변수 우선**


<br/>

#### 3. 재귀함수 ####

- 자신을 재참조하는 함수 (recursive)
- 최근에는 비정형 데이터를 다루는 일이 많기 때문에 많이 사용되는 추세임

- 예시
```
#1부터 n까지의 합을 구할 때

def recursive_add(n):
    if n>0:
        n+=recursive_add(n-1)
    return n

print(recursive_add(3))

```

- 결과
```
10
```
- 재귀함수는 값을 거꾸로 반환함 (스택메모리의 후입선출때문)
- 따라서, 마지막으로 호출된 함수가 먼저 실행

- 'isinstance' 메소드 - **isinstance(변수명, 자료형)**으로 해당 변수가 해당 자료형이 맞는지 체크해줌

<br/>

#### 4. 익명함수 ####

- 이름이 없는 함수 (lambda)
- 한번 사용하고 버리는 함수 (메모리의 효율성을 위해)
- 한 라인에 정리 가능한 간단한 함수를 사용할 때, 유용함

- 형식
```
lambda 파라미터 : 명령어
```

- 예시1
```
#a와 b의 합을 구하는 함수

(lambda a,b:a+b)(1,3)

#a,b,c의 합을 구하는 함수
new_plus = (lambda a,b,c:a+b+c)
#익명함수이지만, 함수명을 붙일수도 있음

```

- 결과1
```
4
```

- 예시2
```
point=[(3,2),(2,1),(1,0),(-1,4)]
sorted(point, key=lambda point:point[1]) #y좌표 기준으로 정렬하고 싶을 때 (그냥 한번 쓰고 버릴 때)
#원래 sorted는 x좌표를 기준으로 정렬됨

```

- 결과2
```
[(1, 0), (2, 1), (3, 2), (-1, 4)]
```

- 후에도 lambda는 유용하게 사용될 것이기 때문에 잘 숙지해놓기 !

<br/>
    

#### 5. 함수형 프로그래밍 ####

- 함수로 나타냄 -> 반복문 X
- 따라서 반복문이 필요하면 '재귀'로 표현
- 그렇기 때문에 불필요한 메모리 사용 X

**List Comprehension**
- 기존 리스트를 사용하여 간단한 다른 리스트를 만드는 방법
- for + append 처럼 사용할 수 있지만, 보다 빠름 !


- 예시1
```
list2=[i for i in range(1,5)]

list2

```

- 결과1
```
[1, 2, 3, 4]
```
- for append와 같은 결과지만, *메모리에 넣지 않고 사라져버리는 ...*
- 종료하는 순간 사라지기 때문에 사용하고 싶으면 새로 변수를 만들어 return을 저장해야함

- 예시2
```
# 0~11 중 2의 배수에 해당하는 값만 리스트에 저장
# [(변수에 적용할 수식) for (변수) in (for문이 돌아가는 범위) 조건]
result=[i for i in range(0,12) if (i>0) and (i%2==0)]
result
```

- 결과2
```
[2, 4, 6, 8, 10]
```

**Map과 비슷한 역할을 하는 'Filter'**
- map은 조건을 만족하지 않으면 None을 채워넣지만
- filter는 조건에 만족하는 값만 리턴해줌

- 예시1
```
#3의 배수만 반환하는 프로그램
list11=list(i for i in range(1,31))

list(filter(lambda x: x%3==0,list11)) 

```

- 결과1
```
[3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
```

**Enumerate & Zip**
- Enumerate : 리스트의 요소를 추출할 때, 인덱스를 붙여 추출해 줌
- 형식
```
enumerate(변수명)
```

- Zip : 2개의 리스트를 병렬적으로 추출함
- 형식
```
zip(list, list)
```

- 예시(enumerate)
```
list1 = ['사과', '바나나', '딸기', '포도', '키위']

for idx, element in enumerate(list1):
    print(idx+1, element) #enumerate로 쉽게 순서 번호를 붙여 출력할 수 있음

```

- 결과(enumerate)
```
1 사과
2 바나나
3 딸기
4 포도
5 키위
```

- 예시(zip)
```
alist = ['사과', '바나나', '딸기', '오렌지'] # 4개
blist = ['Apple', 'Banana', 'Strawberry'] # 3개
clist = [100, 200, 300, 400, 500] # 5개

list(zip(alist,blist,clist)) #가장 길이가 짧은 리스트 길이 기준으로 묶임

```

- 결과(zip)
```
[('사과', 'Apple', 100), ('바나나', 'Banana', 200), ('딸기', 'Strawberry', 300)]
```

- 예시(enumerate & zip)
```
alist = ['사과', '바나나', '딸기']
blist = ['Apple', 'Banana', 'Strawberry']

new_list=list(zip(alist,blist))
for idx, element in enumerate(new_list):
    print(idx+1, element[0], element[1])

```

- 결과(enumerate & zip)
```
1 사과 Apple
2 바나나 Banana
3 딸기 Strawberry
```

**Reduce**
- 이전 결과와 누적해서 반환해주는 함수 (for문과 비슷하게 동작함)
- 형식
```
from functools import reduce
reduce(function, iterable, initializer=None)
```

- 예시
```
reduce(lambda x,y: x+y, list(i for i in range(0,11)))

```

- 결과(enumerate)
```
55
```

<br/>
    

#### 6. list comprehension, map, lambda를 모두 사용한 실습 ####

- 예시1
```
# 이 숫자/문자들을 두 배로 만들고 싶어요! (자료형에 맞게 2배)
numbers = [1, 2, 3, '거', [1, 5]]

list(map((lambda x: x*2),numbers))

```

- 결과1
```
[2, 4, 6, '거거', [1, 5, 1, 5]]
```

- 예시2
```
li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50, 60]

list(map((lambda x,y:x+y),li1,li2)) 
```

- 결과2
```
[11, 22, 33, 44, 55]
```
- 여러개 집합 자료형을 사용할 때는 가장 길이가 짧은 자료형의 길이 기준으로 동작
- (길이가 더 긴 리스트의 나머지 원소는 누락됨)

<br/>

### 표준출력 ###
- 쓰기모드(w)
- 읽기모드(r)
- 추가모드(a)
- flush
  - 인터프리터처럼 한줄씩이 아닌 한번에 처리하는 방법

- 형식
```
with open(파일명, 모드) as 파일을 가리키는 약어:
    print(뭘 쓰려는지, file=약어)
```
- 예시
```
with open('test.txt','w') as f:
    print('다시 안녕하세요 !', file=f)
```

- 결과
```
text.txt라는 파일에 "다시 안녕하세요!"라는 문구가 새겨짐
```
- readline(): 파일의 내용을 **한줄씩 string**으로 리턴
- realines(): 파일의 내용을 **한꺼번에 list**로 리턴
<br/><br/>

## 발견(Discovery): 그 속에서 알게된 점은 무엇인지
**알게된 점**

- 여러가지 함수형 문법을 알게됨

- 특히, 여러 줄의 코드를 간단하게 표현할 수 있는 것 + 메모리를 잡아먹지 않는 코드 활용법을 알게됨

<br/><br/>

## 배운점(Lesson Learned): 어떤 점을 배웠는지

- 복잡한 코드를 간단하게 표현할 수 있는 여러 함수형 문법 (list comprehension, lambda, reduce 등)


<br/><br/>

## 선언(Daclaration): 배우고 알게 된 점을 바탕으로 앞으로 무엇을 하고 싶은지

- gpt를 이용하여 함수형 문법들 예제 풀어보기
```
#  1. R T F C 프레임워크에 맞춰서 작성
#  Role : AI가 수행할 역할을 명확히 정의
#  Task : 수행할 구체적인 작업 기술
#  Format : 결과물의 형식과 길이를 지정
#  Constraints : 준수해야할 규칙과 제한을 명시


"너는 입문자에게 파이썬을 가르치는 개발 강사야. Python에서 {주제: 리스트컴프리헨션}를 배우는 초보자를 위한 학습용 예제를 작성해줘.
아래 형식에 맞춰 작성해:

주제 및 학습 목표: {주제}과 관련된 개념 및 목표 설명.
코드 예제: 주제를 활용한 20줄 이내의 Python 코드 제공.
코드 설명: 초보자가 이해할 수 있도록 각 코드 블록을 설명.
추가 실습 과제: 주제를 확장해 실습할 수 있는 문제 제시.

예제는 이해하기 쉽고 간단하게 작성하며, Python 3 최신 표준을 준수해."
```

- 혹은, codeup 사이트 이용하기
