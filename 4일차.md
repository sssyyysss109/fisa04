<hr>

# 네줄리뷰(Four Lines Review)

<hr>

## 사실(Facts): 어떠한 일들이 있었는지
### 문자열 메소드 (split, replace, strip, join) ###

#### split ####

-문자열 분리 메소드

-형태
```
문자열.split(sep=구분자, maxsplit=분리할 갯수)
```
-sep과 maxsplit을 적으면 위치 바꾸기 가능 **(ex. str.split(maxsplit=3, sep='*'))

-예시
```
str1 = '안녕/안녕/안녕하세요/반가워요/좋은아침입니다'

str1.split(sep='/',maxsplit=4) #파라미터 생략 가능 -> str1.split('/',4) 이런 식으로
```

-결과
```
['안녕', '안녕', '안녕하세요', '반가워요', '좋은아침입니다']
```

#### replace ####

-문자열 치환 메소드

-형태
```
str.replace(old, new[, count])
```
-old와 new는 필수사항

-count는 선택사항

-예시
```
str1 = '안녕 나는 짱구 짱아 짱짱맨 짱 아빠야'

str1.replace('짱','훈',3) #짱을 훈으로 앞에서 3번째까지만
```

-결과
```
'안녕 나는 훈구 훈아 훈짱맨 짱 아빠야'
```

#### strip ####

-문자열 공백 제거 메소드

-형태
```
str.strip([chars])
```
-[chars]는 선택사항


-예시1
```
st2 = '          \t hello   \n        '
print(st2)
st2.lstrip() #왼쪽에 있는 공백만 제거
st2.rstrip() #오른쪽에 있는 공백만 제거
```

-결과1
```
hello   \n        
          \t hello
```

-예시2
```
actors = '1010로미오&줄리엣1010'
actors1 = '로미오1010&줄리엣'
actors1.strip('10') #양끝단에 있는 것만 제거되고, 중간에 있는 것은 제거 X
#그럼 중간에 있는 건 어떻게 제거해야될까?
actors1.replace('1010','') #replace로 그냥 빈문자열로 바꿔버려
```

-결과2
```
로미오&줄리엣
로미오1010&줄리엣
로미오&줄리엣
```

#### join ####

-문자열 집합 메소드 (여러 문자열을 하나의 문자열로 만들어주는)

-모두 자료형 문자열이어야만.

-형태
```
   str.join(iterable)
```

-예시
```
dict1 = {'a': 1234, 'b':356}
' '.join(dict1.values) #dict1.values는 리스트가 X -> 각각 끄집어낼수 X -> 집합형 자료형이 X (이터러블 객체 X)
#형변환을 사용하면 됨
dict11=list(dict1.values())
dict11[0]=str(dict11[0])
dict11[1]=str(dict11[1])
' '.join(dict11)
```

-결과
```
1234 356
```
-딕셔너리에서 join을 이용하려면 dict.keys, dict.values, dict.items가 집합형 자료형이 아니라는 것을 알아두어야 함 !
(**형변환 필수**)

 
#### 여러 메소들을 복합적으로 사용한 예시 ####
-문자열 중 가장 많이 사용된 단어 TOP10 출력해보기

-예시
```
word_list=[]

for word in string2_list:
    word_list.append(word) #단어를 담은 리스트 생성

word_cnt=[]
for word in set(string2_list): #중복되지 않은 단어 리스트 생성
    cnt=word_list.count(word)
    word_cnt.append((cnt,word)) #단어 개수 세서 리스트에 넣기

word_cnt.sort(reverse=True) #내림차순

for cnt, word in word_cnt[:10]: #상위 10개만 뽑기
    print(word_cnt)
```

-> 알고리즘 순서만 기억해놓기 !

#### collections 모듈 ####

- 딕셔너리 활용도 증가
- 그 중, counter.most_common(num) 알아서 중복단어의 개수를 세서 출력해줌

- 예시
```
  import collections

collections.Counter(string2.split()).most_common(10) #알아서 중복단어의 개수를 세줌 + 빈도순 상위 10개 단어 출력
```

-결과
```
[('you', 40),
 ('happy', 35),
 ('i', 27),
 ('clap', 24),
 ('along', 24),
 ('if', 24),
 ('is', 23),
 ('am', 21),
 ('like', 19),
 ('because', 19)]
```

<br/>
    
### 정규식 ### 

-"특정 조건 또는 패턴"을 치환하는 과정을 쉽게 처리할 수 있는 방법

-자주 사용되는 메소드
```
# match() : 문자열의 첫 시작부터 정규식과 매치되는지 조사한다.
# search() : 문자열 전체를 검색하여 정규식과 매치되는지 조사한다.
# findall() : 정규식과 매치되는 모든 문자열(substring)을 리스트로 돌려준다.
# finditer() : 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체로 돌려준다.
```

-예시1
```
str1 = 'abIT aIT IT it AI AI Engineering Engineer deer 한글 010-1234-5678 😊❤ aa👌 '
p=re.compile('[a-zA-Z]+') #1글자이상의 알파벳으로 되어있는 문자열
p.findall(str1)
```

-결과1
```
['abIT',
 'aIT',
 'IT',
 'it',
 'AI',
 'AI',
 'Engineering',
 'Engineer',
 'deer',
 'aa']
```

-예시2
```
str1 = 'abIT aIT IT it AI AI Engineering Engineer deer 한글 010-1234-5678 😊❤ aa👌 '
p=re.compile('[a-zA-Z]*') #알파벳으로 되어있는 문자열 또는 공백(0개)
p.findall(str1) # 예시1과 같은 결과 + 공백이 같이 출력됨
```

-예시3
```
str1 = 'abIT aIT IT it AI AI Engineering Engineer deer 한글 010-1234-5678 😊❤ aa👌 '
p=re.compile('[a-zA-Z]?') #알파벳으로 되어있는 문자(1개) 또는 공백(0개)
p.findall(str1) #결과가 한글자씩 + 공백으로 출력
```

-예시4
```
str1 = 'abIT aIT IT it AI AI Engineering Engineer deer 한글 010-1234-5678 😊❤ aa👌 '
p=re.compile('^[a-zA-Z]+') #알파벳으로 시작하는 문자열이면 해당 시작 단어 출력 
p=re.compile('^[^a-zA-Z]+') #알파벳으로 시작하지 않는 문자 해당 시작 단어 출력
p.findall(str1) 
```
-딕셔너리는 '키중심'으로 동작하기 때문에 유의해야함!

-예시5
```
import re
# re.sub() - 대체
# grouping 소괄화()로 정규식 패턴을 분리하고 1부터 순서대로 끊어서 부른다.
name=input("이름을 입력해주세요.: ")
#두글자인 이름은 익명처리가 안되고있음 -> 해결하기!
if len(name)==2:
    print(re.sub(r'([가-힣])([가-힣]+)',r'\1*',name))
else:
    print(re.sub(r'([가-힣])([가-힣]+)([가-힣])',r'\1*\3',name))#첫번째와 세번째는 그대로 사용하고 가운데만 *로 처리 (한글이름만)
    print(re.sub(r'(\w)(\w+)(\w)',r'\1*\3',name)) #문자로 받을 때 (영어이름도 가능하도록)
```

-결과5
```
이름을 입력해주세요.: alex
a*x
```

-예시6
```
import re
emails = ['python@mail.example.com', 'python+kr@example.com',              # 올바른 형식
          'python-dojang@example.co.kr', 'python_10@example.info',         # 올바른 형식
          'python.dojang@e-xample.com',                                    # 올바른 형식
          '@example.com', 'python@example', 'python@example-com']          # 잘못된 형식

#올바른 이메일 형식만 리턴되도록
pat=re.compile(r"[a-zA-Z0-9-_+.]+@[a-zA-Z0-9-_+.]+[.][a-zA-Z0-9-_+]+")
for address in emails:
    if pat.findall(address):
        print(address)
```

-결과6
```
python@mail.example.com
python+kr@example.com
python-dojang@example.co.kr
python_10@example.info
python.dojang@e-xample.com
```

### 함수 ###

- 똑같은 코드를 또 치고 싶지 않은 개발자의 ...

- getter(조회, 확인) -> 꺼내보는것 -> 원본 변경 X
  setter(변경, 삽입, 수정) -> 이미 존재하는 것을 바꾸는 것 -> 원본 변경 O

-파이썬은 함수를 작성할 때, 입력 자료형을 강제하는 것이 불가능함
 (pydantic 등으로 강제하는 방법도 존재하긴 함 ...)

-함수 안에서 무언가를 추가하하거나 빼면, 원본을 훼손하게 될수도 있음

-'가변인자'는 입력값의 개수가 정해지지 않은 인자를 말함

-예시1
```
def minus2(*args): #파라미터 갯수가 정해져있지 않음
    print(args)

minus2(1)
```

-예시2
```
#a,b,c 세개의 값을 받아서 가장 작은 값을 출력, c에 아무것도 입력하지 않으면 c=0을 디폴트 파라미터로 min_라는 함수 만들어보기

def min_(a,b,c=0):
    print(min(a,b,c))

min_(1,2)
```

-예시3
```
def value(a,b,*c): #a,b,그외 나머지들을 인자로 받아서 출력
    print(f'{a}와 {b}와 나머지들 {c}') #fstring 사용

value(1,2,3,4,5,6,7)
```

-결과3
```
1와 2와 나머지들 (3, 4, 5, 6, 7)
```

<br/><br/>

## 발견(Discovery): 그 속에서 알게된 점은 무엇인지
**알게된 점**

- 정규식이 무엇인지, 그리고 어떻게 사용하는 것인지
(하지만 사용하기 좀 어렵다 ㅠㅠ)

- collections 모듈


<br/><br/>

## 배운점(Lesson Learned): 어떤 점을 배웠는지

- 정규식에서 패턴 찾기 사이트 ( https://regex101.com/ )

- 특정 패턴을 찾거나 치환할 때는 정규식을 사용하자 !


<br/><br/>

## 선언(Daclaration): 배우고 알게 된 점을 바탕으로 앞으로 무엇을 하고 싶은지

- 정규식 활용 더 해보기 ...

